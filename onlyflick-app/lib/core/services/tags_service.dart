// lib/core/services/tags_service.dart

import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'api_service.dart';

/// Mod√®le pour un tag avec ses m√©tadonn√©es
class TagData {
  final String key;
  final String displayName;
  final String emoji;
  final int count;

  const TagData({
    required this.key,
    required this.displayName,
    required this.emoji,
    required this.count,
  });

  factory TagData.fromJson(Map<String, dynamic> json) {
    return TagData(
      key: json['key'] ?? '',
      displayName: json['displayName'] ?? '',
      emoji: json['emoji'] ?? 'üè∑Ô∏è',
      count: json['count'] ?? 0,
    );
  }

  Map<String, dynamic> toJson() => {
        'key': key,
        'displayName': displayName,
        'emoji': emoji,
        'count': count,
      };

  @override
  String toString() => 'TagData(key: $key, displayName: $displayName, count: $count)';
}

/// Service pour la gestion des tags et de leurs statistiques
class TagsService {
  static final ApiService _apiService = ApiService();
  
  // Cache pour √©viter les appels r√©p√©t√©s
  static List<TagData>? _cachedTags;
  static DateTime? _lastCacheUpdate;
  static const Duration _cacheTimeout = Duration(minutes: 5);

  /// R√©cup√®re tous les tags disponibles avec leurs statistiques depuis l'API
  static Future<List<TagData>> getTagsWithStats() async {
    try {
      // V√©rifier le cache
      if (_cachedTags != null && 
          _lastCacheUpdate != null && 
          DateTime.now().difference(_lastCacheUpdate!) < _cacheTimeout) {
        debugPrint('üè∑Ô∏è Utilisation des tags en cache (${_cachedTags!.length} tags)');
        return _cachedTags!;
      }

      debugPrint('üè∑Ô∏è R√©cup√©ration des tags avec statistiques depuis l\'API...');
      
      // ‚úÖ Essayer d'abord l'endpoint tags/stats
      try {
        final response = await _apiService.get<Map<String, dynamic>>(
          '/search/tags/stats',
        );

        if (response.isSuccess && response.data != null) {
          final data = response.data!;
          
          if (data['tags'] != null && data['tags'] is List) {
            List<TagData> tags = [];
            
            for (var tagJson in data['tags']) {
              if (tagJson is Map<String, dynamic>) {
                try {
                  tags.add(TagData.fromJson(tagJson));
                } catch (e) {
                  debugPrint('‚ö†Ô∏è Erreur parsing tag: $e');
                }
              }
            }
            
            // Mettre en cache seulement si on a r√©cup√©r√© des donn√©es valides
            if (tags.isNotEmpty) {
              _cachedTags = tags;
              _lastCacheUpdate = DateTime.now();
              
              debugPrint('‚úÖ ${tags.length} tags avec stats r√©cup√©r√©s depuis API: ${tags.map((t) => '${t.displayName}(${t.count})').join(', ')}');
              return tags;
            }
          }
        }
      } catch (e) {
        debugPrint('‚ö†Ô∏è Endpoint /search/tags/stats non disponible: $e');
      }

      // ‚úÖ Fallback: analyser les posts existants pour extraire les tags
      debugPrint('üîÑ Fallback: analyse des posts pour extraire les tags...');
      return await _getTagsFromPosts();
      
    } catch (e) {
      debugPrint('‚ùå Erreur lors de la r√©cup√©ration des stats tags: $e');
      
      // Fallback final : utiliser les tags par d√©faut
      return await _getFallbackTags();
    }
  }

  /// ‚úÖ M√©thode pour extraire les tags depuis les posts existants
  static Future<List<TagData>> _getTagsFromPosts() async {
    try {
      final response = await _apiService.get<Map<String, dynamic>>(
        '/posts/recommended',
        queryParams: {'limit': '100'}, // R√©cup√©rer plus de posts pour avoir plus de tags
      );

      if (response.isSuccess && response.data != null) {
        final data = response.data!;
        
        // Compter les occurrences de chaque tag
        Map<String, int> tagCounts = {};
        
        if (data['posts'] != null && data['posts'] is List) {
          List<dynamic> posts = data['posts'];
          
          for (var post in posts) {
            if (post['tags'] != null && post['tags'] is List) {
              List<dynamic> postTags = post['tags'];
              for (var tag in postTags) {
                if (tag != null && tag.toString().isNotEmpty) {
                  String backendTag = tag.toString().toLowerCase();
                  tagCounts[backendTag] = (tagCounts[backendTag] ?? 0) + 1;
                }
              }
            }
          }
        }
        
        // Convertir en TagData avec les vrais comptages
        List<TagData> tags = [
          TagData(key: 'tous', displayName: 'Tous', emoji: 'üè∑Ô∏è', count: data['total'] ?? 0),
        ];
        
        // Ajouter les tags trouv√©s avec leurs comptages
        for (String backendTag in tagCounts.keys) {
          String displayName = getTagDisplayName(backendTag);
          String emoji = _getTagEmoji(backendTag);
          int count = tagCounts[backendTag] ?? 0;
          
          if (displayName.isNotEmpty && displayName != 'Tous') {
            tags.add(TagData(
              key: backendTag,
              displayName: displayName,
              emoji: emoji,
              count: count,
            ));
          }
        }
        
        // Ajouter les tags manquants avec count 0
        List<String> allValidTags = _getValidBackendTags();
        for (String validTag in allValidTags) {
          if (!tagCounts.containsKey(validTag)) {
            tags.add(TagData(
              key: validTag,
              displayName: getTagDisplayName(validTag),
              emoji: _getTagEmoji(validTag),
              count: 0,
            ));
          }
        }
        
        // Trier par count d√©croissant (sauf "Tous" qui reste en premier)
        tags.sort((a, b) {
          if (a.key == 'tous') return -1;
          if (b.key == 'tous') return 1;
          return b.count.compareTo(a.count);
        });
        
        // Mettre en cache
        if (tags.isNotEmpty) {
          _cachedTags = tags;
          _lastCacheUpdate = DateTime.now();
          
          debugPrint('‚úÖ ${tags.length} tags extraits depuis posts: ${tags.map((t) => '${t.displayName}(${t.count})').join(', ')}');
          return tags;
        }
      }
      
      // Si √©chec, utiliser les tags par d√©faut
      return await _getFallbackTags();
      
    } catch (e) {
      debugPrint('‚ùå Erreur extraction tags depuis posts: $e');
      return await _getFallbackTags();
    }
  }

  /// R√©cup√®re uniquement les noms des tags (pour compatibilit√©)
  static Future<List<String>> getAvailableTags() async {
    try {
      final tagsWithStats = await getTagsWithStats();
      final tags = tagsWithStats.map((tag) => tag.displayName).toList();
      
      if (tags.isNotEmpty) {
        debugPrint('‚úÖ Tags disponibles r√©cup√©r√©s: $tags');
        return tags;
      }
      
      // Fallback
      return _getFallbackTagNames();
    } catch (e) {
      debugPrint('‚ùå Erreur r√©cup√©ration tags, utilisation fallback: $e');
      return _getFallbackTagNames();
    }
  }

  /// ‚úÖ M√©thode pour r√©cup√©rer les posts filtr√©s par tag
  static Future<Map<String, dynamic>> getPostsByTag(String tag, {
    int limit = 10,
    int offset = 0,
  }) async {
    try {
      Map<String, String> queryParams = {
        'limit': limit.toString(),
        'offset': offset.toString(),
      };
      
      // Convertir le tag d'affichage vers le backend
      if (tag != 'Tous') {
        String backendTag = getTagKey(tag);
        if (backendTag.isNotEmpty && backendTag != 'tous') {
          queryParams['tags'] = backendTag;
          debugPrint('üîç Recherche posts avec tag backend: $backendTag (depuis: $tag)');
        }
      }
      
      final response = await _apiService.get<Map<String, dynamic>>(
        '/posts/recommended',
        queryParams: queryParams,
      );

      if (response.isSuccess && response.data != null) {
        final result = response.data!;
        debugPrint('‚úÖ Posts r√©cup√©r√©s: ${result['posts']?.length ?? 0} posts pour tag: $tag');
        return result;
      } else {
        debugPrint('‚ùå Erreur API getPostsByTag: ${response.error}');
        throw Exception('Failed to load posts: ${response.error}');
      }
      
    } catch (e) {
      debugPrint('‚ùå Erreur lors de la r√©cup√©ration des posts par tag: $e');
      rethrow;
    }
  }

  /// R√©cup√®re les statistiques d'un tag sp√©cifique
  static Future<int> getTagCount(String tagDisplayName) async {
    try {
      final tagsWithStats = await getTagsWithStats();
      final tag = tagsWithStats.firstWhere(
        (t) => t.displayName.toLowerCase() == tagDisplayName.toLowerCase(),
        orElse: () => const TagData(key: '', displayName: '', emoji: '', count: 0),
      );
      return tag.count;
    } catch (e) {
      debugPrint('‚ùå Erreur r√©cup√©ration count pour $tagDisplayName: $e');
      return 0;
    }
  }

  /// R√©cup√®re les m√©tadonn√©es d'un tag (nom, emoji, etc.)
  static Future<TagData?> getTagData(String tagDisplayName) async {
    try {
      final tagsWithStats = await getTagsWithStats();
      final tag = tagsWithStats.firstWhere(
        (t) => t.displayName.toLowerCase() == tagDisplayName.toLowerCase(),
        orElse: () => const TagData(key: '', displayName: '', emoji: '', count: 0),
      );
      
      if (tag.key.isEmpty) return null;
      return tag;
    } catch (e) {
      debugPrint('‚ùå Erreur r√©cup√©ration data pour $tagDisplayName: $e');
      return null;
    }
  }

  /// ‚úÖ Convertit un nom d'affichage en cl√© backend
  static String getTagKey(String displayName) {
    const Map<String, String> tagDisplayToKey = {
      'Tous': 'tous',
      'Wellness': 'wellness',
      'Beaut√©': 'beaute',
      'Art': 'art',
      'Musique': 'musique',
      'Cuisine': 'cuisine',
      'Football': 'football',
      'Basket': 'basket',
      'Basketball': 'basket', // Alias
      'Mode': 'mode',
      'Cin√©ma': 'cinema',
      'Actualit√©s': 'actualites',
      'Mangas': 'mangas',
      'Memes': 'memes',
      'Tech': 'tech',
    };
    
    return tagDisplayToKey[displayName] ?? displayName.toLowerCase();
  }

  /// ‚úÖ Convertit une cl√© backend en nom d'affichage
  static String getTagDisplayName(String key) {
    const Map<String, String> tagKeyToDisplay = {
      'tous': 'Tous',
      'wellness': 'Wellness',
      'beaute': 'Beaut√©',
      'art': 'Art',
      'musique': 'Musique',
      'cuisine': 'Cuisine',
      'football': 'Football',
      'basket': 'Basketball',
      'mode': 'Mode',
      'cinema': 'Cin√©ma',
      'actualites': 'Actualit√©s',
      'mangas': 'Mangas',
      'memes': 'Memes',
      'tech': 'Tech',
    };
    
    return tagKeyToDisplay[key.toLowerCase()] ?? key;
  }

  /// ‚úÖ Retourne l'emoji d'un tag backend
  static String _getTagEmoji(String backendTag) {
    const Map<String, String> tagEmojis = {
      'wellness': 'üßò',
      'beaute': 'üíÑ',
      'art': 'üé®',
      'musique': 'üéµ',
      'cuisine': 'üç≥',
      'football': '‚öΩ',
      'basket': 'üèÄ',
      'mode': 'üëó',
      'cinema': 'üé¨',
      'actualites': 'üì∞',
      'mangas': 'üìö',
      'memes': 'üòÇ',
      'tech': 'üíª',
    };
    
    return tagEmojis[backendTag.toLowerCase()] ?? 'üè∑Ô∏è';
  }

  /// ‚úÖ Retourne la liste des tags backend valides
  static List<String> _getValidBackendTags() {
    return [
      'wellness',
      'beaute',
      'art',
      'musique',
      'cuisine',
      'football',
      'basket',
      'mode',
      'cinema',
      'actualites',
      'mangas',
      'memes',
      'tech',
    ];
  }

  /// Invalide le cache pour forcer un rechargement
  static void invalidateCache() {
    _cachedTags = null;
    _lastCacheUpdate = null;
    debugPrint('üóëÔ∏è Cache des tags invalid√©');
  }

  /// ‚úÖ Force le rafra√Æchissement des tags
  static Future<List<String>> refreshTags() async {
    debugPrint('üîÑ Rafra√Æchissement forc√© des tags...');
    invalidateCache();
    return await getAvailableTags();
  }

  /// Teste si l'API des tags est accessible
  static Future<bool> isApiAvailable() async {
    try {
      final response = await _apiService.get<Map<String, dynamic>>(
        '/search/tags/stats',
      );
      return response.isSuccess;
    } catch (e) {
      debugPrint('‚ùå API tags non accessible: $e');
      return false;
    }
  }

  /// ‚úÖ Tags de fallback en cas d'erreur API (comptages r√©alistes)
  static Future<List<TagData>> _getFallbackTags() async {
    debugPrint('üîÑ Utilisation des tags de fallback avec comptages estim√©s');
    
    return [
      const TagData(key: 'tous', displayName: 'Tous', emoji: 'üè∑Ô∏è', count: 0),
      const TagData(key: 'art', displayName: 'Art', emoji: 'üé®', count: 10),
      const TagData(key: 'musique', displayName: 'Musique', emoji: 'üéµ', count: 10),
      const TagData(key: 'tech', displayName: 'Tech', emoji: 'üíª', count: 7),
      const TagData(key: 'cuisine', displayName: 'Cuisine', emoji: 'üç≥', count: 8),
      const TagData(key: 'wellness', displayName: 'Wellness', emoji: 'üßò', count: 7),
      const TagData(key: 'beaute', displayName: 'Beaut√©', emoji: 'üíÑ', count: 7),
      const TagData(key: 'mode', displayName: 'Mode', emoji: 'üëó', count: 5),
      const TagData(key: 'football', displayName: 'Football', emoji: '‚öΩ', count: 5),
      const TagData(key: 'basket', displayName: 'Basketball', emoji: 'üèÄ', count: 5),
      const TagData(key: 'cinema', displayName: 'Cin√©ma', emoji: 'üé¨', count: 5),
      const TagData(key: 'actualites', displayName: 'Actualit√©s', emoji: 'üì∞', count: 5),
      const TagData(key: 'mangas', displayName: 'Mangas', emoji: 'üìö', count: 5),
      const TagData(key: 'memes', displayName: 'Memes', emoji: 'üòÇ', count: 5),
    ];
  }

  /// ‚úÖ Noms des tags de fallback
  static List<String> _getFallbackTagNames() {
    return [
      'Tous',
      'Art',
      'Musique', 
      'Tech',
      'Cuisine',
      'Wellness',
      'Beaut√©',
      'Mode',
      'Football',
      'Basketball',
      'Cin√©ma',
      'Actualit√©s',
      'Mangas',
      'Memes',
    ];
  }

  /// R√©cup√®re les tags les plus populaires (les plus utilis√©s)
  static Future<List<TagData>> getPopularTags({int limit = 5}) async {
    try {
      final tagsWithStats = await getTagsWithStats();
      
      // Exclure "Tous" et trier par count d√©croissant
      final popularTags = tagsWithStats
          .where((tag) => tag.key != 'tous' && tag.count > 0)
          .toList()
        ..sort((a, b) => b.count.compareTo(a.count));
      
      return popularTags.take(limit).toList();
    } catch (e) {
      debugPrint('‚ùå Erreur r√©cup√©ration tags populaires: $e');
      return [];
    }
  }

  /// Recherche des tags par nom
  static Future<List<TagData>> searchTags(String query) async {
    if (query.isEmpty) return [];
    
    try {
      final allTags = await getTagsWithStats();
      
      return allTags
          .where((tag) => 
              tag.displayName.toLowerCase().contains(query.toLowerCase()) ||
              tag.key.toLowerCase().contains(query.toLowerCase()))
          .toList();
    } catch (e) {
      debugPrint('‚ùå Erreur recherche tags: $e');
      return [];
    }
  }

  /// Retourne les statistiques g√©n√©rales des tags
  static Future<Map<String, dynamic>> getTagsOverview() async {
    try {
      final tags = await getTagsWithStats();
      
      final totalTags = tags.length - 1; // Exclure "Tous"
      final totalPosts = tags.isNotEmpty ? tags.first.count : 0; // "Tous" contient le total
      final tagsWithPosts = tags.where((tag) => tag.key != 'tous' && tag.count > 0).length;
      
      return {
        'total_tags': totalTags,
        'total_posts': totalPosts,
        'tags_with_posts': tagsWithPosts,
        'empty_tags': totalTags - tagsWithPosts,
        'last_update': _lastCacheUpdate?.toIso8601String() ?? '',
      };
    } catch (e) {
      debugPrint('‚ùå Erreur r√©cup√©ration overview tags: $e');
      return {};
    }
  }
}