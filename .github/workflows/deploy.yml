name: ðŸš€ OnlyFlick CI/CD Pipeline

on:
    push:
        branches: [main, develop]
        paths-ignore:
            - '**.md'
            - 'docs/**'
    pull_request:
        branches: [main]
        types: [opened, synchronize, reopened]
    workflow_dispatch:
        inputs:
            environment:
                description: 'Environment to deploy to'
                required: true
                default: 'staging'
                type: choice
                options:
                    - staging
                    - production
            skip_tests:
                description: 'Skip tests (emergency deploy only)'
                required: false
                default: false
                type: boolean

env:
    DOCKER_REGISTRY: ghcr.io
    IMAGE_BASE: ${{ github.repository }}
    GO_VERSION: '1.21.5'
    FLUTTER_VERSION: '3.13.9'
    CACHE_KEY_PREFIX: onlyflick-v2
    NODE_VERSION: '18'

permissions:
    contents: read
    packages: write
    security-events: write
    id-token: write

jobs:
    # ==========================================
    # ðŸ“‹ Pipeline Prerequisites & Validation
    # ==========================================
    validate-changes:
        name: ðŸ” Validate Changes
        runs-on: ubuntu-latest
        outputs:
            backend-changed: ${{ steps.changes.outputs.backend }}
            frontend-changed: ${{ steps.changes.outputs.frontend }}
            k8s-changed: ${{ steps.changes.outputs.k8s }}
            
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  
            - name: ðŸ” Detect changes
              uses: dorny/paths-filter@v2
              id: changes
              with:
                  filters: |
                      backend:
                        - 'api/**'
                        - 'cmd/**'
                        - 'internal/**'
                        - 'pkg/**'
                        - 'go.mod'
                        - 'go.sum'
                        - 'Dockerfile'
                      frontend:
                        - 'frontend/**'
                      k8s:
                        - 'k8s/**'
                        - 'scripts/**'

    # ==========================================
    # ðŸ§ª Testing Phase
    # ==========================================
    test-backend:
        name: ðŸ§ª Backend Tests
        runs-on: ubuntu-latest
        needs: validate-changes
        if: needs.validate-changes.outputs.backend-changed == 'true' || github.event.inputs.skip_tests != 'true'
        
        strategy:
            matrix:
                test-type: [unit, integration, e2e]
        
        services:
            postgres:
                image: postgres:15-alpine
                env:
                    POSTGRES_PASSWORD: testpass
                    POSTGRES_USER: testuser
                    POSTGRES_DB: testdb
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432
            redis:
                image: redis:alpine
                options: >-
                    --health-cmd "redis-cli ping"
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 6379:6379

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ”§ Setup Go
              uses: actions/setup-go@v4
              with:
                  go-version: ${{ env.GO_VERSION }}
                  cache: true

            - name: ðŸ“¦ Cache Go modules
              uses: actions/cache@v3
              with:
                  path: ~/go/pkg/mod
                  key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
                  restore-keys: |
                      ${{ runner.os }}-go-

            - name: ðŸ“¥ Download dependencies
              run: go mod download

            - name: ðŸ§ª Run ${{ matrix.test-type }} tests
              env:
                  SECRET_KEY: ${{ secrets.SECRET_KEY || '12345678901234567890123456789012' }}
                  DATABASE_URL: postgres://testuser:testpass@localhost:5432/testdb?sslmode=disable
                  REDIS_URL: redis://localhost:6379
                  CI: true
              run: |
                  mkdir -p coverage
                  go test ./tests/${{ matrix.test-type }}/... -v \
                      -coverprofile=coverage/${{ matrix.test-type }}-coverage.out \
                      -covermode=atomic \
                      -race \
                      -timeout=30m \
                      -json > coverage/${{ matrix.test-type }}-results.json

            - name: ðŸ“Š Upload test results
              uses: actions/upload-artifact@v3
              if: always()
              with:
                  name: backend-${{ matrix.test-type }}-results
                  path: |
                      coverage/${{ matrix.test-type }}-*.out
                      coverage/${{ matrix.test-type }}-*.json
                  retention-days: 30

    test-frontend:
        name: ðŸŽ¨ Frontend Tests
        runs-on: ubuntu-latest
        needs: validate-changes
        if: needs.validate-changes.outputs.frontend-changed == 'true' || github.event.inputs.skip_tests != 'true'
        
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  submodules: recursive

            - name: ðŸ“¦ Cache Flutter
              uses: actions/cache@v3
              with:
                  path: |
                      ${{ runner.tool_cache }}/flutter
                      ~/.pub-cache
                  key: ${{ runner.os }}-flutter-${{ env.FLUTTER_VERSION }}

            - name: ðŸ”§ Setup Flutter
              uses: subosito/flutter-action@v2
              with:
                  flutter-version: ${{ env.FLUTTER_VERSION }}
                  channel: 'stable'
                  cache: true

            - name: ðŸ“¥ Install frontend dependencies
              working-directory: frontend/onlyflick-app
              run: |
                  flutter clean
                  flutter pub get
                  flutter pub deps

            - name: ðŸ§ª Run Flutter tests
              working-directory: frontend/onlyflick-app
              run: |
                  flutter test --coverage --reporter=expanded
                  flutter test --reporter=json > test-results.json

            - name: ðŸ” Analyze Flutter code
              working-directory: frontend/onlyflick-app
              run: |
                  flutter analyze --fatal-infos
                  dart format --set-exit-if-changed lib/

            - name: ðŸ“Š Upload coverage
              uses: codecov/codecov-action@v3
              with:
                  directory: frontend/onlyflick-app/coverage

    # ==========================================
    # ðŸ” Security & Quality Gates
    # ==========================================
    security-scan:
        name: ðŸ” Security Scan
        runs-on: ubuntu-latest
        needs: [validate-changes]
        if: always()

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ðŸ” Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: 'fs'
                  scan-ref: '.'
                  format: 'sarif'
                  output: 'trivy-results.sarif'
                  severity: 'CRITICAL,HIGH'

            - name: ðŸ“¤ Upload Trivy results
              uses: github/codeql-action/upload-sarif@v2
              if: always()
              with:
                  sarif_file: 'trivy-results.sarif'

            - name: ðŸ”’ Run Gosec Security Scanner
              uses: securecodewarrior/github-action-gosec@master
              with:
                  args: '-fmt sarif -out gosec-results.sarif ./...'

            - name: ðŸ”‘ Check for secrets
              uses: trufflesecurity/trufflehog@main
              with:
                  path: ./
                  base: main
                  head: HEAD

    code-quality:
        name: ðŸ“‹ Code Quality
        runs-on: ubuntu-latest
        needs: [test-backend]
        if: always()

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ðŸ”§ Setup Go
              uses: actions/setup-go@v4
              with:
                  go-version: ${{ env.GO_VERSION }}

            - name: ðŸ“¥ Download test artifacts
              uses: actions/download-artifact@v3
              with:
                  pattern: backend-*-results
                  merge-multiple: true
                  path: coverage/

            - name: ðŸ§¹ Run golangci-lint
              uses: golangci/golangci-lint-action@v3
              with:
                  version: latest
                  args: --timeout=10m --out-format=colored-line-number

            - name: ðŸ“Š Merge coverage reports
              run: |
                  echo "mode: atomic" > coverage/merged.out
                  find coverage -name "*.out" -exec tail -n +2 {} + >> coverage/merged.out
                  go tool cover -html=coverage/merged.out -o coverage/coverage.html
                  go tool cover -func=coverage/merged.out | tee coverage/coverage.txt

            - name: ðŸ“Š SonarCloud Scan
              uses: SonarSource/sonarcloud-github-action@master
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

            - name: ðŸ“Š Upload final coverage
              uses: actions/upload-artifact@v3
              with:
                  name: final-coverage-report
                  path: coverage/
                  retention-days: 30

    # ==========================================
    # ðŸ—ï¸ Build Phase
    # ==========================================
    build-backend:
        name: ðŸ—ï¸ Build Backend
        runs-on: ubuntu-latest
        needs: [test-backend, security-scan, code-quality]
        if: always() && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped') && needs.security-scan.result == 'success'
        
        outputs:
            backend-image: ${{ steps.image.outputs.backend-image }}
            backend-digest: ${{ steps.build.outputs.digest }}
            backend-sbom: ${{ steps.sbom.outputs.sbom }}

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ”§ Set up Docker Buildx
              uses: docker/setup-buildx-action@v3
              with:
                  platforms: linux/amd64,linux/arm64

            - name: ðŸ”‘ Login to Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.DOCKER_REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ·ï¸ Extract metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-backend
                  tags: |
                      type=ref,event=branch
                      type=ref,event=pr
                      type=sha,prefix={{branch}}-
                      type=raw,value=latest,enable={{is_default_branch}}
                      type=semver,pattern={{version}}
                      type=semver,pattern={{major}}.{{minor}}

            - name: ðŸ—ï¸ Build and push backend
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  platforms: linux/amd64,linux/arm64
                  provenance: true
                  sbom: true

            - name: ðŸ” Generate SBOM
              id: sbom
              run: |
                  echo "sbom=generated" >> $GITHUB_OUTPUT

            - name: ðŸ”’ Sign container image
              if: github.ref == 'refs/heads/main'
              uses: sigstore/cosign-installer@v3

            - name: ðŸ·ï¸ Set image output
              id: image
              run: echo "backend-image=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-backend:${{ github.sha }}" >> $GITHUB_OUTPUT

    build-frontend:
        name: ðŸŽ¨ Build Frontend
        runs-on: ubuntu-latest
        needs: [test-frontend]
        if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
        
        outputs:
            frontend-image: ${{ steps.image.outputs.frontend-image }}
            frontend-digest: ${{ steps.build.outputs.digest }}

        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  submodules: recursive

            - name: Setup Flutter
              uses: subosito/flutter-action@v2
              with:
                  flutter-version: ${{ env.FLUTTER_VERSION }}
                  channel: 'stable'

            - name: Build Flutter Web
              working-directory: frontend/onlyflick-app
              run: |
                  flutter clean
                  flutter pub get
                  flutter build web --release --web-renderer html

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Login to Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.DOCKER_REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            - name: Extract metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-frontend
                  tags: |
                      type=ref,event=branch
                      type=ref,event=pr
                      type=sha,prefix={{branch}}-
                      type=raw,value=latest,enable={{is_default_branch}}

            - name: Create Dockerfile for frontend
              run: |
                  cat > frontend/onlyflick-app/Dockerfile << 'EOF'
                  FROM nginx:alpine
                  COPY build/web /usr/share/nginx/html
                  COPY nginx.conf /etc/nginx/conf.d/default.conf
                  EXPOSE 80
                  CMD ["nginx", "-g", "daemon off;"]
                  EOF

            - name: Create nginx config
              run: |
                  cat > frontend/onlyflick-app/nginx.conf << 'EOF'
                  server {
                      listen 80;
                      server_name localhost;
                      root /usr/share/nginx/html;
                      index index.html;
                      
                      location / {
                          try_files $uri $uri/ /index.html;
                          add_header Cache-Control "no-cache, no-store, must-revalidate";
                      }
                      
                      location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                          expires 1y;
                          add_header Cache-Control "public, immutable";
                      }
                  }
                  EOF

            - name: Build and push frontend
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: frontend/onlyflick-app
                  file: frontend/onlyflick-app/Dockerfile
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  platforms: linux/amd64,linux/arm64

            - name: Set image output
              id: image
              run: echo "frontend-image=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-frontend:${{ github.sha }}" >> $GITHUB_OUTPUT

    # ==========================================
    # ðŸš€ Deployment Phase
    # ==========================================
    deploy-staging:
        name: ðŸš€ Deploy to Staging
        runs-on: ubuntu-latest
        needs: [build-backend, build-frontend, validate-changes]
        if: |
            always() && 
            (github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch') &&
            (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
            (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped')
        environment: 
            name: staging
            url: https://staging.onlyflick.local

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: Setup kubectl
              uses: azure/setup-kubectl@v3
              with:
                  version: 'v1.28.0'

            - name: Configure kubeconfig
              run: |
                  mkdir -p $HOME/.kube
                  echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config

            - name: Update Kubernetes manifests
              run: |
                  sed -i "s|image: .*backend.*|image: ${{ needs.build-backend.outputs.backend-image }}|g" k8s/backend/onlyflick-backend-deployment.yaml
                  sed -i "s|image: .*frontend.*|image: ${{ needs.build-frontend.outputs.frontend-image }}|g" k8s/frontend/onlyflick-frontend-deployment.yaml

            - name: Deploy to staging
              run: |
                  kubectl create namespace onlyflick-staging --dry-run=client -o yaml | kubectl apply -f -
                  
                  kubectl create secret generic onlyflick-backend-secret \
                    --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                    --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL_STAGING }}" \
                    --from-literal=IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}" \
                    --from-literal=IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}" \
                    --from-literal=IMAGEKIT_URL_ENDPOINT="${{ secrets.IMAGEKIT_URL_ENDPOINT }}" \
                    -n onlyflick-staging \
                    --dry-run=client -o yaml | kubectl apply -f -
                  
                  kubectl apply -f k8s/backend/ -n onlyflick-staging
                  kubectl apply -f k8s/frontend/ -n onlyflick-staging
                  kubectl apply -f k8s/ingress/ -n onlyflick-staging
                  
                  kubectl rollout status deployment/onlyflick-backend -n onlyflick-staging --timeout=300s
                  kubectl rollout status deployment/onlyflick-frontend -n onlyflick-staging --timeout=300s

            - name: Run smoke tests
              run: |
                  sleep 30
                  
                  kubectl run test-backend --image=curlimages/curl --rm -i --restart=Never -n onlyflick-staging -- \
                    curl -f http://onlyflick-backend-service.onlyflick-staging.svc.cluster.local/health
                  
                  kubectl run test-frontend --image=curlimages/curl --rm -i --restart=Never -n onlyflick-staging -- \
                    curl -f http://onlyflick-frontend-service.onlyflick-staging.svc.cluster.local

            - name: ðŸ›¡ï¸ Validate deployment security
              run: |
                  # VÃ©rifier les images signÃ©es
                  echo "Validating container security..."
                  
            - name: ðŸš€ Deploy with Helm
              run: |
                  helm upgrade --install onlyflick-staging ./k8s/helm-chart \
                      --namespace onlyflick-staging \
                      --create-namespace \
                      --set backend.image="${{ needs.build-backend.outputs.backend-image }}" \
                      --set frontend.image="${{ needs.build-frontend.outputs.frontend-image }}" \
                      --set environment=staging \
                      --wait --timeout=10m

            - name: ðŸ§ª Comprehensive smoke tests
              run: |
                  # Test de sanitÃ© Ã©tendu
                  curl -f https://staging.onlyflick.local/health
                  curl -f https://api-staging.onlyflick.local/health
                  
                  # Test de performance basique
                  curl -w "@curl-format.txt" -s -o /dev/null https://staging.onlyflick.local

    deploy-production:
        name: ðŸŒŸ Deploy to Production
        runs-on: ubuntu-latest
        needs: [build-backend, build-frontend, deploy-staging]
        if: |
            always() && 
            github.ref == 'refs/heads/main' && 
            github.event_name == 'push' &&
            needs.deploy-staging.result == 'success'
        environment: 
            name: production
            url: https://onlyflick.local

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: Setup kubectl
              uses: azure/setup-kubectl@v3
              with:
                  version: 'v1.28.0'

            - name: Configure kubeconfig
              run: |
                  mkdir -p $HOME/.kube
                  echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

            - name: Update Kubernetes manifests
              run: |
                  sed -i "s|image: .*backend.*|image: ${{ needs.build-backend.outputs.backend-image }}|g" k8s/backend/onlyflick-backend-deployment.yaml
                  sed -i "s|image: .*frontend.*|image: ${{ needs.build-frontend.outputs.frontend-image }}|g" k8s/frontend/onlyflick-frontend-deployment.yaml

            - name: Deploy to production
              run: |
                  kubectl create namespace onlyflick --dry-run=client -o yaml | kubectl apply -f -
                  
                  kubectl create secret generic onlyflick-backend-secret \
                    --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                    --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL_PRODUCTION }}" \
                    --from-literal=IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}" \
                    --from-literal=IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}" \
                    --from-literal=IMAGEKIT_URL_ENDPOINT="${{ secrets.IMAGEKIT_URL_ENDPOINT }}" \
                    -n onlyflick \
                    --dry-run=client -o yaml | kubectl apply -f -
                  
                  kubectl apply -f k8s/backend/ -n onlyflick
                  kubectl apply -f k8s/frontend/ -n onlyflick
                  kubectl apply -f k8s/ingress/ -n onlyflick
                  
                  kubectl rollout status deployment/onlyflick-backend -n onlyflick --timeout=600s
                  kubectl rollout status deployment/onlyflick-frontend -n onlyflick --timeout=600s

            - name: Run production smoke tests
              run: |
                  sleep 60
                  
                  kubectl run prod-test-backend --image=curlimages/curl --rm -i --restart=Never -n onlyflick -- \
                    curl -f http://onlyflick-backend-service.onlyflick.svc.cluster.local/health
                  
                  kubectl run prod-test-frontend --image=curlimages/curl --rm -i --restart=Never -n onlyflick -- \
                    curl -f http://onlyflick-frontend-service.onlyflick.svc.cluster.local

            - name: ðŸ“‹ Pre-deployment checklist
              run: |
                  echo "## Pre-deployment Checklist" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… All tests passed" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… Security scans completed" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… Staging deployment successful" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… Images signed and verified" >> $GITHUB_STEP_SUMMARY

            - name: ðŸš€ Blue/Green deployment
              run: |
                  # DÃ©ploiement blue/green pour zero-downtime
                  helm upgrade onlyflick ./k8s/helm-chart \
                      --namespace onlyflick \
                      --set backend.image="${{ needs.build-backend.outputs.backend-image }}" \
                      --set frontend.image="${{ needs.build-frontend.outputs.frontend-image }}" \
                      --set environment=production \
                      --wait --timeout=15m

            - name: ðŸ”„ Automated rollback on failure
              if: failure()
              run: |
                  echo "ðŸš¨ Deployment failed, initiating rollback..."
                  helm rollback onlyflick -n onlyflick
                  
            - name: ðŸ“Š Post-deployment validation
              run: |
                  # Tests de production Ã©tendus
                  ./scripts/production-health-check.sh

    # ==========================================
    # ðŸ“Š Post-deployment & Reporting
    # ==========================================
    post-deployment:
        name: ðŸ“Š Post-deployment Tasks
        runs-on: ubuntu-latest
        needs: [deploy-production]
        if: always()

        steps:
            - name: Generate deployment report
              run: |
                  echo "# OnlyFlick Deployment Report" > deployment-report.md
                  echo "" >> deployment-report.md
                  echo "**Commit:** ${{ github.sha }}" >> deployment-report.md
                  echo "**Branch:** ${{ github.ref_name }}" >> deployment-report.md
                  echo "**Triggered by:** ${{ github.actor }}" >> deployment-report.md
                  echo "**Deployment time:** $(date -u)" >> deployment-report.md
                  echo "" >> deployment-report.md
                  echo "## Images deployed:" >> deployment-report.md
                  echo "- Backend: ${{ needs.build-backend.outputs.backend-image }}" >> deployment-report.md
                  echo "- Frontend: ${{ needs.build-frontend.outputs.frontend-image }}" >> deployment-report.md
                  echo "" >> deployment-report.md
                  echo "## URLs:" >> deployment-report.md
                  echo "- App: https://onlyflick.local" >> deployment-report.md
                  echo "- API: https://api.onlyflick.local" >> deployment-report.md
                  echo "- Monitoring: https://grafana.local" >> deployment-report.md

            - name: Notify Slack
              uses: 8398a7/action-slack@v3
              if: always()
              with:
                  status: custom
                  channel: '#deployments'
                  webhook_url: ${{ secrets.SLACK_WEBHOOK }}
                  custom_payload: |
                      {
                        "text": "OnlyFlick Deployment ${{ job.status }}",
                        "attachments": [{
                          "color": "${{ job.status == 'success' && 'good' || 'danger' }}",
                          "fields": [
                            {"title": "Environment", "value": "Production", "short": true},
                            {"title": "Commit", "value": "${{ github.sha }}", "short": true},
                            {"title": "Author", "value": "${{ github.actor }}", "short": true},
                            {"title": "Duration", "value": "${{ github.event.head_commit.timestamp }}", "short": true}
                          ]
                        }]
                      }

            - name: Send email notification
              uses: dawidd6/action-send-mail@v3
              if: failure()
              with:
                  server_address: smtp.gmail.com
                  server_port: 587
                  username: ${{ secrets.MAIL_USERNAME }}
                  password: ${{ secrets.MAIL_PASSWORD }}
                  subject: "OnlyFlick Deployment Failed"
                  to: ${{ secrets.NOTIFICATION_EMAIL }}
                  from: OnlyFlick CI/CD
                  body: |
                      Deployment failed for commit ${{ github.sha }}
                      
                      Check the workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
