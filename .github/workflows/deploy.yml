name: 🚀 OnlyFlick CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_BASE: ${{ github.repository }}
  GO_VERSION: '1.21'
  FLUTTER_VERSION: '3.13.0'

jobs:
  # ==========================================
  # Phase 1: Tests et Quality Gates
  # ==========================================
  test-backend:
    name: 🧪 Backend Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: 📦 Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: 📥 Download dependencies
        run: go mod download

      - name: 🧪 Run unit tests
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DATABASE_URL: postgres://testuser:testpass@localhost:5432/testdb?sslmode=disable
        run: |
          go test ./tests/unit/... -v -coverprofile=unit-coverage.out
          go tool cover -html=unit-coverage.out -o unit-coverage.html

      - name: 🔗 Run integration tests
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DATABASE_URL: postgres://testuser:testpass@localhost:5432/testdb?sslmode=disable
        run: |
          go test ./tests/integration/... -v -coverprofile=integration-coverage.out
          go tool cover -html=integration-coverage.out -o integration-coverage.html

      - name: 🎯 Run E2E tests
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DATABASE_URL: postgres://testuser:testpass@localhost:5432/testdb?sslmode=disable
        run: |
          go test ./tests/e2e/... -v -coverprofile=e2e-coverage.out
          go tool cover -html=e2e-coverage.out -o e2e-coverage.html

      - name: 📊 Upload coverage reports
        uses: actions/upload-artifact@v3
        with:
          name: coverage-reports
          path: |
            *-coverage.html
            *-coverage.out

  test-frontend:
    name: 🎨 Frontend Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: 🔧 Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'
          cache: true

      - name: 📦 Install frontend dependencies
        working-directory: frontend/onlyflick-app
        run: |
          flutter clean
          flutter pub get

      - name: 🧪 Run Flutter tests
        working-directory: frontend/onlyflick-app
        run: |
          flutter test --coverage
          flutter test --reporter=json > test-results.json

      - name: 🔍 Analyze Flutter code
        working-directory: frontend/onlyflick-app
        run: flutter analyze

      - name: 📊 Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: flutter-test-results
          path: frontend/onlyflick-app/test-results.json

  # ==========================================
  # Phase 2: Security & Quality Analysis
  # ==========================================
  security-scan:
    name: 🔐 Security Scan
    runs-on: ubuntu-latest
    needs: [test-backend]

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔍 Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: 📤 Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: 🔒 Run Gosec Security Scanner
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: './...'

  code-quality:
    name: 📋 Code Quality
    runs-on: ubuntu-latest
    needs: [test-backend]

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🔧 Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: 🧹 Run golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
          args: --timeout=10m

      - name: 📊 SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # ==========================================
  # Phase 3: Build & Package
  # ==========================================
  build-backend:
    name: 🏗️ Build Backend
    runs-on: ubuntu-latest
    needs: [test-backend, security-scan, code-quality]
    
    outputs:
      backend-image: ${{ steps.image.outputs.backend-image }}
      backend-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔑 Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 🏷️ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: 🏗️ Build and push backend
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: 🏷️ Set image output
        id: image
        run: echo "backend-image=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-backend:${{ github.sha }}" >> $GITHUB_OUTPUT

  build-frontend:
    name: 🎨 Build Frontend
    runs-on: ubuntu-latest
    needs: [test-frontend]
    
    outputs:
      frontend-image: ${{ steps.image.outputs.frontend-image }}
      frontend-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: 🔧 Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'

      - name: 🏗️ Build Flutter Web
        working-directory: frontend/onlyflick-app
        run: |
          flutter clean
          flutter pub get
          flutter build web --release --web-renderer html

      - name: 🔧 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔑 Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 🏷️ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: 📝 Create Dockerfile for frontend
        run: |
          cat > frontend/onlyflick-app/Dockerfile << 'EOF'
          FROM nginx:alpine
          COPY build/web /usr/share/nginx/html
          COPY nginx.conf /etc/nginx/conf.d/default.conf
          EXPOSE 80
          CMD ["nginx", "-g", "daemon off;"]
          EOF

      - name: 📝 Create nginx config
        run: |
          cat > frontend/onlyflick-app/nginx.conf << 'EOF'
          server {
              listen 80;
              server_name localhost;
              root /usr/share/nginx/html;
              index index.html;
              
              location / {
                  try_files $uri $uri/ /index.html;
                  add_header Cache-Control "no-cache, no-store, must-revalidate";
              }
              
              location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }
          }
          EOF

      - name: 🏗️ Build and push frontend
        id: build
        uses: docker/build-push-action@v5
        with:
          context: frontend/onlyflick-app
          file: frontend/onlyflick-app/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: 🏷️ Set image output
        id: image
        run: echo "frontend-image=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_BASE }}-frontend:${{ github.sha }}" >> $GITHUB_OUTPUT

  # ==========================================
  # Phase 4: Deploy to Staging
  # ==========================================
  deploy-staging:
    name: 🚀 Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    environment: staging

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: 🔑 Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config

      - name: 📝 Update Kubernetes manifests
        run: |
          sed -i "s|image: .*backend.*|image: ${{ needs.build-backend.outputs.backend-image }}|g" k8s/backend/onlyflick-backend-deployment.yaml
          sed -i "s|image: .*frontend.*|image: ${{ needs.build-frontend.outputs.frontend-image }}|g" k8s/frontend/onlyflick-frontend-deployment.yaml

      - name: 🚀 Deploy to staging
        run: |
          # Create namespace if not exists
          kubectl create namespace onlyflick-staging --dry-run=client -o yaml | kubectl apply -f -
          
          # Create secrets
          kubectl create secret generic onlyflick-backend-secret \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL_STAGING }}" \
            --from-literal=IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}" \
            --from-literal=IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}" \
            --from-literal=IMAGEKIT_URL_ENDPOINT="${{ secrets.IMAGEKIT_URL_ENDPOINT }}" \
            -n onlyflick-staging \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy backend
          kubectl apply -f k8s/backend/ -n onlyflick-staging
          
          # Deploy frontend
          kubectl apply -f k8s/frontend/ -n onlyflick-staging
          
          # Deploy ingress
          kubectl apply -f k8s/ingress/ -n onlyflick-staging
          
          # Wait for deployment
          kubectl rollout status deployment/onlyflick-backend -n onlyflick-staging --timeout=300s
          kubectl rollout status deployment/onlyflick-frontend -n onlyflick-staging --timeout=300s

      - name: 🧪 Run smoke tests
        run: |
          # Wait for services to be ready
          sleep 30
          
          # Test backend health
          kubectl run test-backend --image=curlimages/curl --rm -i --restart=Never -n onlyflick-staging -- \
            curl -f http://onlyflick-backend-service.onlyflick-staging.svc.cluster.local/health
          
          # Test frontend availability
          kubectl run test-frontend --image=curlimages/curl --rm -i --restart=Never -n onlyflick-staging -- \
            curl -f http://onlyflick-frontend-service.onlyflick-staging.svc.cluster.local

  # ==========================================
  # Phase 5: Deploy to Production
  # ==========================================
  deploy-production:
    name: 🌟 Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, deploy-staging]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: 🔑 Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

      - name: 📝 Update Kubernetes manifests
        run: |
          sed -i "s|image: .*backend.*|image: ${{ needs.build-backend.outputs.backend-image }}|g" k8s/backend/onlyflick-backend-deployment.yaml
          sed -i "s|image: .*frontend.*|image: ${{ needs.build-frontend.outputs.frontend-image }}|g" k8s/frontend/onlyflick-frontend-deployment.yaml

      - name: 🚀 Deploy to production
        run: |
          # Create namespace if not exists
          kubectl create namespace onlyflick --dry-run=client -o yaml | kubectl apply -f -
          
          # Create secrets
          kubectl create secret generic onlyflick-backend-secret \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL_PRODUCTION }}" \
            --from-literal=IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}" \
            --from-literal=IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}" \
            --from-literal=IMAGEKIT_URL_ENDPOINT="${{ secrets.IMAGEKIT_URL_ENDPOINT }}" \
            -n onlyflick \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy with rolling update strategy
          kubectl apply -f k8s/backend/ -n onlyflick
          kubectl apply -f k8s/frontend/ -n onlyflick
          kubectl apply -f k8s/ingress/ -n onlyflick
          
          # Wait for deployment
          kubectl rollout status deployment/onlyflick-backend -n onlyflick --timeout=600s
          kubectl rollout status deployment/onlyflick-frontend -n onlyflick --timeout=600s

      - name: 🧪 Run production smoke tests
        run: |
          sleep 60
          
          # Comprehensive health checks
          kubectl run prod-test-backend --image=curlimages/curl --rm -i --restart=Never -n onlyflick -- \
            curl -f http://onlyflick-backend-service.onlyflick.svc.cluster.local/health
          
          kubectl run prod-test-frontend --image=curlimages/curl --rm -i --restart=Never -n onlyflick -- \
            curl -f http://onlyflick-frontend-service.onlyflick.svc.cluster.local

      - name: 📊 Setup monitoring alerts
        run: |
          # Deploy monitoring if not exists
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            --namespace monitoring --create-namespace \
            --set grafana.adminPassword="${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
            --wait

  # ==========================================
  # Phase 6: Post-deployment
  # ==========================================
  post-deployment:
    name: 📋 Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()

    steps:
      - name: 📊 Generate deployment report
        run: |
          echo "# 🚀 OnlyFlick Deployment Report" > deployment-report.md
          echo "" >> deployment-report.md
          echo "**Commit:** ${{ github.sha }}" >> deployment-report.md
          echo "**Branch:** ${{ github.ref_name }}" >> deployment-report.md
          echo "**Triggered by:** ${{ github.actor }}" >> deployment-report.md
          echo "**Deployment time:** $(date -u)" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Images deployed:" >> deployment-report.md
          echo "- Backend: ${{ needs.build-backend.outputs.backend-image }}" >> deployment-report.md
          echo "- Frontend: ${{ needs.build-frontend.outputs.frontend-image }}" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## URLs:" >> deployment-report.md
          echo "- 🎨 App: https://onlyflick.local" >> deployment-report.md
          echo "- 🚀 API: https://api.onlyflick.local" >> deployment-report.md
          echo "- 📊 Monitoring: https://grafana.local" >> deployment-report.md

      - name: 💬 Notify Slack
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

      - name: 📧 Send email notification
        uses: dawidd6/action-send-mail@v3
        if: failure()
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "❌ OnlyFlick Deployment Failed"
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: OnlyFlick CI/CD
          body: |
            Deployment failed for commit ${{ github.sha }}
            
            Check the workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}


